	INCLUDE	"../labels.asm"

	ORG	$0000
; Cold reset
RST00:	DI
	LD	BC, $692B
RST00L:	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,RST00L	; No instruction fetch from 0008, for IF1 compatibility
	JP	RESET
	DEFS	$10 - $

; Return to ROM1
RST10:	INC	SP
	INC	SP
	JP	SWAP1
	DEFS	$18 - $

; Collect a character
RST18:	LD	HL,(CH_ADD)
	LD	A,(HL)
TEST_CHAR:
	CALL	SKIP_OVER
	RET	NC

; Collect next character
RST20:	CALL	CH_ADD_1
	JR	TEST_CHAR
	DEFS	$28 - $

; Calculator restart
RST28:	JP	L335B		; CALCULATE
	DEFS	$30 - $

; Call routine from ROM1
RST30:	EX	(SP),HL
	PUSH	AF
	LD	A,(HL)
	JP	CALL_ROM1
	DEFS	$38 - $

; IM1 routine
RST38:	PUSH	AF
	LD	A,SWAP/$100
	PUSH	AF
	INC	SP
	LD	A,1
	PUSH	AF
	INC	SP
	XOR	A
	PUSH	AF
	INC	SP
	LD	A,RST38
	PUSH	AF
	INC	SP
	RST	RST10

CALL_ROM1:
	LD	(TARGET),A
	INC	HL
	LD	A,(HL)
	LD	(TARGET+1),A	; target address in TARGET
	POP	AF
	INC	HL
	EX	(SP),HL		; return address on stack
	PUSH	HL
	LD	HL,SWAP
	EX	(SP),HL		; return address, SWAP on stack
	PUSH	HL
	LD	HL,(TARGET)
	EX	(SP),HL		; return address, SWAP, target address on stack
ROM1SW:	JP	SWAP1		; this one is performance-critical

	DEFS	$66 - $
NMI:	PUSH	AF
	PUSH	HL
	LD	HL,(NMIADD)
	PUSH	HL
	LD	A,H
	CP	$3F
	RET	NC
	OR	L
	JR	NZ,ROM1SW
NONMI:	POP	HL
	POP	HL
	POP	AF
	RETN

F_SCAN:	LD	HL,10
	ADD	HL,SP
	LD	A,(HL)
	INC	HL
	EX	AF,AF'
	LD	A,(HL)
	LD	E,L
	LD	D,H
	DEC	HL
	DEC	HL
	LD	BC,10
	LDDR
	POP	HL
	LD	H,A
	EX	AF,AF'
	LD	L,A
JP_HL:	JP	(HL)

SKIP_OVER:
	CP	$21
	RET	NC
	CP	$0D
	RET	Z
	CP	1
	RET	C
	CP	6
	CCF
	RET	NC
	CP	$18
	CCF
	RET	C
	INC	HL
	CP	$16
	JR	C,SKIPS2
	INC	HL
SKIPS2:	SCF
	LD	(CH_ADD),HL
	RET

CH_ADD_1:
	LD	HL,(CH_ADD)
TEMP_PTR1:
	INC	HL
TEMP_PTR2:
	LD	(CH_ADD),HL
	LD	A,(HL)
	RET

ZX:	LD	SP,$0051	; 0000
	RST	RST10

RESET:	LD	A,7
	OUT	($FE),A
	LD	A,$80
	OUT	($FF),A		; EX-ROM, IRQ, BLACK ON WHITE, SCREEN0
	LD	A,$3F
	LD	I,A
	LD	A,$7F
	IN	A,($FE)
	RRA			; SPACE pressed?
	JR	NC,ZX		; jump if so.
	LD	HL,INIT_5B00
	LD	DE,$5B00
	LD	BC,INIT_5B00_L
	LDIR
	LD	L,E
	LD	H,D
	INC	DE
	LD	(HL),$00
	LD	BC,$FFFF-INIT_5B00_E
	LDIR
	LD	(P_RAMT),HL
	LD	DE,$3EAF		; last byte of U
	LD	BC,$00A8
	EX	DE,HL
	LDDR
	EX	DE,HL
	INC	HL
	LD	(UDG),HL
	DEC	HL
	LD	BC,$0140
	LD	(RASP),BC
	LD	(RAMTOP),HL
NEWTS:	LD	HL,$3C00
	LD	(CHARS),HL
	LD	HL,(RAMTOP)
	LD	(HL),$3E
	DEC	HL
	LD	SP,HL
	DEC	HL
	DEC	HL
	LD	(ERR_SP),HL
	LD	HL,NMIVEC
	LD	(NMIADD),HL
	IM	1
	LD	IY,ERR_NR
	LD	(IY+FLAGS-ERR_NR),$10	; TS2060 mode
	EI
	LD	HL,CHINFO
	LD	(CHANS),HL
	LD	DE,L15AF
	LD	BC,$0015
	EX	DE,HL
	RST	RST30
	DEFW	LDIRR
	EX	DE,HL
	DEC	HL
	LD	(DATADD),HL
	INC	HL
	LD	(PROG),HL
	LD	(VARS),HL
	LD	(HL),$80
	INC	HL
	LD	(E_LINE),HL
	LD	(HL),$0D
	INC	HL
	LD	(HL),$80
	INC	HL
	LD	(WORKSP),HL
	LD	(STKBOT),HL
	LD	(STKEND),HL
; measure framerate
	LD	BC,$FFFF
	LD	HL,FRAMES
	HALT
	LD	A,(HL)
FRAMERT:INC	BC
	CP	(HL)
	JR	Z,FRAMERT
	RST	RST30
	DEFW	STACKBC
	RST	RST28
	DEFB	$34,$40,$43,$22,$03	; literal 331800
	DEFB	$01			; exchange
	DEFB	$05			; division
	DEFB	$38			; end_calc
	RST	RST30
	DEFW	L2DD5		; FP-TO-A
	LD	(BEAT),A

	LD	HL,P_OUT	; output service routine in this ROM
	LD	(CHINFO),HL
	LD	(CHINFO+5),HL
	LD	(CHINFO+15),HL
	LD	A,$38
	LD	(ATTR_P),A
	LD	(ATTR_T),A
	LD	(BORDCR),A
	LD	HL,$0523
	LD	(REPDEL),HL
	DEC	(IY+KSTATE-ERR_NR)
	DEC	(IY+KSTATE+4-ERR_NR)
	LD	HL,L15C6
	LD	DE,STRMS
	LD	BC,$000E
	RST	RST30
	DEFW	LDIRR
	LD	(IY+DF_SZ-ERR_NR),$02
	RST	RST30
	DEFW	L0D6B		; CLS
	LD	DE,COPYRIGHT
	CALL	STDERR_MSG
	LD	DE,CPR_MSG
	PUSH	DE
	RST	RST10

INIT_5B00:	EQU	$
; This stuff does not run here, it gets copied to $5B00
	ORG	$5B00
SWAP:	PUSH	AF
	XOR	A
	OUT	($F4),A
	POP	AF
	EX	(SP),HL
	RES	5,H
	EX	(SP),HL
	RET

P_OUT:	LD	HL,PR_OUT
P_OUT1:	EQU	P_OUT+1
SWAP2:	PUSH	HL
	JR	SWAP

TEMPO:	DEFB	120		; in BPM for PLAY
BEAT:	EQU	$		; framerate constant for PLAY
PLAY_ST:EQU	BEAT+1		; PLAY state
TARGET:	EQU	PLAY_ST+2	; address in ROM1

INIT_5B00_E:	EQU	$

INIT_5B00_L:	EQU	$ - $5B00

	ORG	INIT_5B00 + INIT_5B00_L



	DEFS	L0554 - $ - 5	; POP AF \ RET in ROM1
SWAP1:	PUSH	AF
	LD	A, 1
	OUT	($F4), A
; Control returned to ROM1

RUN_CONT:
	INC	B
	DJNZ	SWAP1		; separator mismatch
	ADD	A,$C9-PLAY_T
	LD	C,A
	JR	C,SWAP1		; old token instruction
	DEC	B
	POP	HL		; discard REPORT_C
	LD	HL,P_END
	ADD	HL,BC
	INC	B
	LD	C,(HL)
	ADD	HL,BC
	CP	PLAY_T + $53
	JR	NC,GET_PARAM
ERROR_C:RST	$30
	DEFW	REPORT_C

SCAN_LOOP:
	LD	HL,(T_ADDR)
GET_PARAM:
	LD	A,(HL)
	INC	HL
	LD	(T_ADDR),HL
	LD	BC,SCAN_LOOP
	PUSH	BC
	LD	C,A
	CP	$20
	JR	NC,SEPARATOR
	LD	HL,CMDCLASS2
	LD	B,$00
	ADD	HL,BC
	LD	C,(HL)
	ADD	HL,BC
	PUSH	HL
	RST	$18
	DEC	B
	RET

SEPARATOR:
	RST	$18
	CP	C
	JR	NZ,ERROR_C
	RST	$20
	RET

; Same as L16DB in ROM1
INDEXER_1:
	INC	HL
INDEXER:LD	A,(HL)
	OR	A
	RET	Z
	CP	C
	INC	HL
	JR	NZ,INDEXER_1
	SCF
	RET

LV_CONT:PUSH	HL
	LD	HL,L28B2	; LOOK-VARS, no long string names
	EX	(SP),HL
	RST	$10

	INCLUDE	"instructions.asm"
	INCLUDE	"channels.asm"
	INCLUDE	"reportz.asm"
	INCLUDE	"reports.asm"
	INCLUDE	"tokens.asm"

	DEFS	LIST_HOOK - $2000 - $


ONERR_DO:	EQU	SWAP1
INDEX_CONT:	EQU	SWAP1
LIST_CONT:	EQU	SWAP1
SCAN_CONT:	EQU	SWAP1
SUB_CONT:	EQU	SWAP1
STRNG_CONT:	EQU	SWAP1
DIGIT_CONT:	EQU	SWAP1
GOTO_CONT:	EQU	SWAP1
FOR_CONT:	EQU	SWAP1
SKIP_FOR_CONT:	EQU	SWAP1
NEXT_CONT:	EQU	SWAP1
RETURN_CONT:	EQU	SWAP1
MAIN_ADD_CONT:	EQU	SWAP1
ERR_CONT:	EQU	SWAP1
LOCAL_CONT:	EQU	SWAP1
STEP_CONT:	EQU	SWAP1

; jump table from ROM1
	JP	INDEX_CONT
	JP	LIST_CONT
	JP	SCAN_CONT
	JP	SUB_CONT
	JP	STRNG_CONT
	JP	DIGIT_CONT
	JP	GOTO_CONT
	JP	FOR_CONT
	JP	SKIP_FOR_CONT
	JP	NEXT_CONT
	JP	LV_CONT
	JP	RETURN_CONT
	JP	MAIN_ADD_CONT
	JP	ERR_CONT
	JP	RUN_CONT
	JP	LOCAL_CONT
	JP	NEWTS
	JP	STEP_CONT
	JP	TEMPS_CONT
	JP	F_SCAN

; this routine mirrors ROM1 to keep CALCULATE simple
	DEFS	$1F05 - $
TEST5SP:LD	HL,(STKEND)
	ADD	HL,BC
	JR	C,REPORT_4
	EX	DE,HL
	LD	HL,$0050
	ADD	HL,DE
	JR	C,REPORT_4
	SBC	HL,SP
	RET	C

REPORT_4:LD	HL,L1F15
	PUSH	HL
	RST	$10

	DEFS	$2000 - $
