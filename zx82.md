# ZX82 Replacement ROM for ZX Spectrum

## Introduction

In 1982, the ROM program with which the ZX Spectrum (both the 16k and the 48k versions) shipped was a proof-of-concept 
prototype, meant to be replaced as soon as the final version was ready. Alas, for various reasons it never happened.
Several subsystems in the ROM remained unfinished and quite a few bugs remained together with legacy solutions from ZX81 
which were planned to be upgraded for the more powerful machine.

This ROM attempts to be what the ZX Spectrum's final ROM could have been, should it have been finished. The Manual written 
by dr. Steve Vickers served as its primary specification. Both authors of the original ROM, dr. Steve Vickers and John Grant 
have been interviewed by email in the course of its creation. As much as possible, compatibility with existing ZX Spectrum 
software and hardware has been maintained by preserving important entry points. If you find some software or hardware that 
is not compatible with this ROM, please file an issue. I cannot promise to resolve it, but it will be certainly considered.

In addition to fixing bugs or finishing unfinished subsystems, this ROM also contains a few changes aiming at extensibility. 
These changes have been made in such a way as to not degrade performance compared with the ROM with which the ZX Spectrum 
shipped, mainly providing alternative execution paths upon error conditions.

This document describes all changes made to the ROM and is aimed at both users and developers.

## Interrupt Subsystem

### Non-Maskable Interrupt (NMI)

In the original ROM, the system variable NMIADD (address `$5CB0`) is initialized to zero, causing the NMI service routine 
to reset. Any change to its value causes non-maskable interrupts to be ignored. There is plenty of evidence in the ROM and 
in the literature that this is not the intended behavior. In this ROM, NMIADD is initialized to a warm restart routine 
returning the user to the command line, if possible (acting like a stronger `BREAK`) and the service routine has been 
modified to execute it upon NMI. If NMIADD is changed to zero, it will ignore NMI events.

Authors of extension ROMs that page over this ROM are advised to copy the service routine from this ROM so that NMI behavior 
does not depend on which ROM bank happens to be paged in and upon initialization point NMIADD to a small routine 
in RAM paging in the appropriate ROM bank before jumping to the intended NMI handler.

### Maskable Interrupt (IM1)

All dependencies on the value of IY have been eliminated from the maskable frame interrupt service routine. Thus, any 
Z80 register can be safely changed while interrupts are enabled. The functionality of the IM1 service routine has not 
changed: it increments the 24-bit frame counter and reads the keyboard.

## The I/O Subsystem

### I/O Abstraction Model

The I/O abstraction with streams and channels has not been finished in the original ROM; according to Steve Vickers, the 
code in there is a plug. In this ROM, it has been extended to the point that it allows writing device drivers for 
the screen and the keyboard, allowing real or virtual terminals, pipes, completely different video hardware and many 
other interesting and useful things. This is mainly achieved through making `RST $10` call the output service routine 
with the **carry flag set**, while other functionality of the device is exposed through calling the output service 
routine with the the carry flag cleared. Such calls to the output service routine are called `IOCTL`.

By convention, `IOCTL` with register `A` holding zero resets the hardware attached to the channel. For the `S` channel,
it clears the screen, aborts stateful output sequences (such as color controls), resets the pixel pointer to the origin,
restores permanent attributes and places the caret to the top left corner. For the `K` channel, it only clears the 
console part of the screen, resets it to two rows, places the caret to the bottom left corner and aborts stateful input 
and output sequences. The `P` channel flushes the printer buffer in addition to aborting stateful output sequences.

Other `IOCTL` calls are not standardized, the same code might have a very different meaning for different 
devices. All access to abstract peripherial devices is routed through the appropriate channels' service routines.

### Keyboard Inputs

The keyboard click sound has been moved to the input service routine of the `K` channel and it thus indicates that 
a typed character has been read off the channel. `INPUT` from other channels no longer emit a click after each byte 
read. Furthermore, setting system variable `PIP` (address `$5C39`) to zero disables keyboard clicks altogether. It is 
initialized to 1.

As a side effect, switching to and from `Extended` input mode also emits a keyboard click. Prompts such as `scroll?` or 
`Start tape, then press any key...` no longer crash upon pressing mode keys, but also respond with an audible click to 
any keypress. If you wish to record tape audio without these clicks, zero `PIP` first.

### Control Characters

As one can expect reading the manual, cursor movement controls `CHR$ 8` through `CHR$ 11` move the caret, if sent to
`S` or `K` channels. `CHR$ 12` clears the screen.

`CHR$ 14` and `CHR$ 15` indicate that the next character is a cursor, which should be displayed `FLASH`ing or in 
`INVERSE`, respectively, for the editor cursor and the line cursor. Device drivers thus have great freedom in how 
they display these cursors. The line cursor is only displayed in automatic listing, explicit `LIST` and `LLIST` 
commands do not display it. The default `S` channel driver displays the line cursor in inverse, as can be seen in the 
mock screenshots of the manual. Alternative device drivers can highlight the entire program line, for example. 
Similarly, the editor cursor is now displayed through the output service routine and can thus be changed by the `K` 
channel driver.

The tabulator control `CHR$ 6` also delimits `INPUT` values in addition to the newline `CHR$ 13`. This way, comma 
separated outputs in `PRINT` or `LPRINT` can be read into individual variables by `INPUT` as originally intended.

Hitting `DELETE` with the cursor after attribute control sequences deletes the whole sequence.

### Graphics

`CLS` resets the `S` channel via `IOCTL 0`.

High resolution graphics commands `PLOT`, `DRAW` and `CIRCLE` are also routed through the `S` channel's output service 
routine as follows:

Attribute changes are sent into the channel as control sequences, with the carry flag set.

`PLOT` calls `IOCTL 2`, that is the output service routine with the **carry flag cleared** and register `A` holding the 
value 2. The two coordinates are on the calculator stack.

`DRAW` with two arguments calls `IOCTL 3`, `DRAW` with three arguments calls `IOCTL 4` with the arguments on the calculator 
stack.

`CIRCLE` calls `IOCTL 5` with the three arguments on the calculator stack. The circle-drawing algorithm has also been 
changed to a faster and more accurate one.

## The BASIC Interpreter

## The Calculator Subsystem

### Arithmetics

### User-Defined Functions

## Extensibility

### Writing New Device Drivers

### Extending the Expression Scanner

### Adding New BASIC Instructions

### Extending Existing BASIC Instructions

### Adding New Error Reports

### Adding Local Contexts and Variables

### Other Possibilities
