<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
	<title>Become A Wizard</title>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
	<style type="text/css">
	@font-face {
		font-family: 'ZX';
		src: url('font/ZXSpectrumNext.ttf') format('truetype');
	}
	body {
		margin: 5em;
		padding: 1em;
		font-family: Helvetica, Geneva, Arial, sans-serif;
	}
	code {
		font-family: ZX;
	}
	pre {
		font-family: ZX;
	}
	td {
		padding-right: 2em;
	}
	div.figure {
		font-style: italic;
		text-align: center;
		padding: 1em;
	}
	div.frame {
		border-style: solid;
		border-width: 1px;
		padding-left: 1.5em;
		padding-right: 1.5em;
	}
	</style>
</head>
<body>

<h1>Become A Wizard</h1>

<em>This is the manual to the ZX85 computer, a project dedicated to 
Steve Vickers, the author of the manual and the firmware for the ZX
Spectrum computer.</em>

<h2>Contents</h2>
<ol>
	<li><a href="#intro">Introduction</a>
	<li><a href="#console">Meet the Console</a>
	<li><a href="#basics">The Basics of BASIC</a>
	<li><a href="#first">Guess the Number</a>
	<li><a href="#second">2048</a>
</ol>

<h2><a id="intro" />Introduction</h2>

<p>Welcome to <strong>ZX85</strong>, a programmable general-purpose computer for introducing children 
between the ages of 6 and 106 to the centuries-old tradition of <em><strong>wizardry</strong></em>. 
One could also say &quot;<em>regular symbolic manipulations under a Turing-complete set of 
rules</em>&quot; instead of &quot;wizardry&quot; and that would be certainly correct, but the latter 
seems a more fitting expression for the art of <em>creating</em> functioning mechanisms of unlimited 
complexity by merely describing them in a special language. Wizardry has been around for much longer 
than computers, so while <em>computer programming</em> is certainly wizardry, there is more to it than 
programming computers. A large part of mathematics and science is also wizardry and so is genetic 
engineering and many other important human endeavors. While capable wizards are today among the most 
sought-after specialists, mastering this art is its own reward, being one of the most stimulating 
intellectual exercises.</p>

<p>In this book, the first uses of important terms are set in <em><strong>bold italic</strong></em>. 
Usually, you will find the explanation of these terms somewhere around their first use. If not, you 
can look them up elsewhere or ask someone who knows what they mean. Framed texts are either 
<strong>notes</strong>, providing additional information typically relating the discussed topic to the 
broader context of the world beyond the ZX85 or <strong>trivia</strong>, interesting facts related to 
the discussed topic, often providing a historical perspective or <strong>challenges</strong>. The 
first word in the frame, set in <strong>bold regular</strong> tells you which one that particular 
frame is. Texts that you should see on the screen, such as keywords, program line numbers, listings, 
reports and so on, are set in the native font of <code>ZX85</code>.</p>



<p><em>To be continued...</em></p>

<h2><a id="console" />Meet the Console</h2>

<p>The <em><strong>console</strong></em> is how wizards talk to 
computers, in their own language. Unlike the 
<em><strong>desktop</strong></em>, which is what muggles use to get the 
computer do what they need, the console allows you, in principle, to 
make the computer do <em>anything</em> that the computer is capable of 
doing at all. It might seem less fancy, but it is far more powerful and 
expressive than the desktop. Different computers might speak different 
languages on their console, but they are, in many ways, similar. </p>

<p>The language your ZX85 understands is called <code>BASIC</code>, 
which stands for
<strong>B</strong>eginner's 
<strong>A</strong>ll-purpose
<strong>S</strong>ymbolic 
<strong>I</strong>nstruction
<strong>C</strong>ode.

There are many dialects of BASIC; ours is an evolution of <em>ZX 
BASIC</em>, developed for Sinclair's ZX line of computers in the early 
1980's. In particular, it is to a large extent backwards compatible with 
that of the <em><strong>ZX Spectrum</strong></em>, upon which ZX85 is 
based.</p>

<p>When you turn on your ZX85, it performs a quick self-test and greets
you with the following message near the bottom of the screen:
<pre>
© 2019 ePoint Systems Ltd
© 1982 Sinclair Research Ltd
</pre>
</p>

<p>You are using the console now. It is, essentially a dialog with the 
computer, similar to instant messaging. You type something, hit the 
ENTER key and the computer responds. ENTER is just about the most 
important key on the keyboard. Just pressing it means, &quot;Okay computer, 
I've typed in your orders. Now go and obey them.&quot;</p>
 
<p>As you start typing, you can immediately notice that the screen 
is divided into two parts by a black stripe with a rainbow: </p>
<img src="stripe.png" alt="BASIC:1 L ////" height="16" width="512"/>

<p>In fact, the part <em>below</em> the stripe is the console, the part 
<em>above</em> it is the <em><strong>canvas</strong></em>. Inside the 
stripe, you find the following information: <code>BASIC</code> stands 
for the kind of input the console expects from you. In this case, it 
expects a sequence of </em>statements</em> in BASIC. Then you have 
<code>:1</code>, which just indicates that you are about to type the 
<em>first</em> statement. Near the middle of the stripe, you see an 
<code>L</code> character, which is the current <em><strong>input 
mode</strong></em>. It tells you that if you press a letter key, it will 
produce a <em><strong>lower-case</strong></em> letter (try it!). The 
rest is just decoration.</p>

<p>The blinking square is the so-called <em><strong>cursor</strong></em> 
which shows you where what you type is going to appear. If you have 
already typed in anything, you can move the cursor using the arrow keys. 
You can also delete what is before the cursor (which is normally what 
you have typed last) by hitting the DELETE key.</p>

<p>If you press CAPS LOCK, the mode changes to <code>C</code> which 
stands for <em><strong>capital-case</strong></em> letters (try!). You 
can change back to <code>L</code> mode by hitting CAPS LOCK again. You 
can also type capital-case letters in <code>L</code> mode by pressing 
and holding the SHIFT key <em>before</em> hitting the letter key. The 
SHIFT key needs to be pressed while you are hitting the letter key in 
order for it to produce a capital letter. If you keep any key pressed 
long enough, it will repeat its function. To type the symbols on either 
number or letter keys, you should press the SYM key (also called 
<em><strong>Symbol Shift</strong></em>) similarly to how you type 
capital-case letters with SHIFT.</p>

<div class="frame">
<p><strong>Note:</strong> On many <em>other</em> computers, the symbols 
on number keys are typed with the SHIFT key, while the symbols on letter 
keys are typed with some other shift-like key (typically ALT GR). 
<strong><em>Not on a ZX!</em></strong> Here, all symbols are 
consistently typed with Symbol Shift, while SHIFT'ed numbers are 
performing the functions of control keys (for example, SHIFT+1 is the 
same as EDIT, which will undo everything you have typed so far). Be 
careful with those.</p>
</div>

<p>Now you know enough to start chatting with the ZX85.</p>


<h2><a id="basics"/>The Basics of BASIC</h2>

<p>If you try to greet the computer by typing <code>Hello ZX!</code> and 
hitting ENTER, the cursor will jump to after the first letter. This is 
the computer's tactful way of telling you it does not understand a word 
you're saying. In fact, the cursor is moved to after the first character 
that the computer did not understand; the very first one, in this case.</p>
 
<p>Any valid statement in ZX BASIC must begin with a so-called 
<em><strong>instruction keyword</strong></em>. They are, in alphabetical 
order, the following:</p>

<table>
<tr>
<td>
<pre>
ASSERT
BEEP
BORDER
BRIGHT
CAT
CIRCLE
CLEAR
CLOSE #
CLS
CONTINUE
COPY
DATA
DEF FN
DEF PROC
DELETE
DIM
</pre>
</td>
<td>
<pre>
DRAW
ELSE
END IF
END PROC
END WHILE
ERASE
EXIT
FLASH
FOR
FORMAT
GO SUB
GO TO
IF
INK
INPUT
INVERSE
</pre>
</td>
<td>
<pre>
LET
LIST
LLIST
LOAD
LPRINT
MERGE
MOVE
NEW
NEXT
ON ERROR
OPEN #
OUT
OVER
PALETTE
PAPER
PAUSE
</pre>
</td>
<td>
<pre>
PLAY
PLOT
POKE
POP
PRINT
PROC
RANDOMIZE
READ
REM
RENUM
REPEAT
RESTORE
RETURN
RUN
SAVE
STACK
</pre>
</td>
<td>
<pre>
STEP
STOP
UNTIL
USR
VERIFY
WHILE
YIELD









</pre>
</td>
</tr>
</table>

<p>If you type <code>Draw.</code> and hit ENTER, you will notice that as 
soon as you type the period, all the letters of the word 
<code>DRAW</code> are turned to capitals, an extra space is inserted 
before the period and the cursor is flashing after the period. The 
computer does still not understand what this is supposed to mean, though 
it understands a bit more than last time.</p>

<div class="frame">
<p><strong>Note:</strong> Even though the keywords of BASIC are mostly 
English words, <em>BASIC is not English</em>. For the computer to 
understand what you type, it needs to be correct BASIC, not correct 
English. For instance, in BASIC, you do not end statements with a 
period.</p>
</div>

<p>If you move the cursor around, the computer won't let you move it 
inside the (now capitalized) keyword anymore; it jumps from one side, to 
the other. That is because it has recognized the keyword and now treats 
it as a single unit, a so-called <em><strong>token</strong></em>.</p>

<div class="frame">
<p><strong>Trivia:</strong> Statements instructing the 
computer to answer us in writing begin with the <code>PRINT</code> 
keyword. The reason for this is historical: computers got consoles 
before they became able to display anything on screens. In those days, 
the console's output was a roll of paper on which things were literally 
PRINTed. While this has no longer been the case for many decades now, 
the keyword stuck.</p>

<div class=figure>
<img src="https://timedotcom.files.wordpress.com/2014/04/kemenyteaches1.jpg"
width="600px" height="448px" alt="John Kemeny teaches BASIC">
<figcaption>John Kemeny, the inventor of BASIC teaches it to students at
Dartmouth College back when consoles were teletype machines and Dartmouth
was not yet a co-ed institution.</figcaption>
</div>
</div>

<p>So let's try this: type <code>PRINT 2+2</code> and hit ENTER. The 
computer dutifully writes <code>4</code> on the canvas and reports
<pre>
0 OK, 0:1
</pre>
on the console. Note, that we get the same result no matter which letters 
are capitalized in the <code>PRINT</code> keyword; <code>pRiNt 2+2</code> 
would work just the same.</p>

<p>What happened here? The <code>4</code> is, as you might have guessed, 
the <em><strong>evaluation</strong></em> of <code>2+2</code>. <code>OK</code> means what 
you'd think it means: that there was no error in <em><strong>executing</strong></em> this 
statement. The <code>0:1</code> after the comma tells us that this was 
the first statement (<code>:1</code>, same as in the black stripe) of a 
sequence entered from the console. The very first <code>0</code> in the 
report is the <em><strong>report code</strong></em> identifiying the report. 
<code>0</code> stands for <code>OK</code>. While we need to talk to the 
ZX85 in BASIC, it reports to us in English. However, it can be changed 
to report in other human languages as well, in which case the text of 
the report might change to the point of unintelligibility for those who 
do not know that particular language, but the report code remains the 
same, no matter what the langauge of the report is. Thus, one can 
understand what the report says even without understanding the language 
in which the computer is reporting, given a full list of error codes. If 
the computer needs to read its own or another computer's reports, it 
can just look at the report code, ignoring the text in a language which
it does not understand (such as English).</p>

<p>So, now you can use the computer as a calculator. But if you type 
<code>PRINT Hello</code> and hit ENTER, instead of a greeting on the 
canvas, we get an error report:</p>
<pre>
2 Variable not found, 0:1
</pre>

<p>This is because <code>Hello</code> is treated as a 
<em><strong>name</strong></em> of a <em><strong>variable</strong></em> 
(more on this a bit later), not as a text to print. If we mean a 
specific text, in BASIC, we must put it inside double quotes.
<code>PRINT &quot;Hello&quot;</code> actually does write 
<code>Hello</code> on the canvas.</p>

<div class="frame">
<p><strong>Note:</strong> Computers are very fussy that you should 
distinguish between the digit zero and the letter O. To make it 
absolutely clear, zero appears on the screen as <code>0</code>, with a 
slash through it. You also need to distinguish between the digit one 
(<code>1</code>), the capital letter i (<code>I</code>) and the small 
letter L (<code>l</code>). All ten digits are on the top row of the 
keyboard. Furthermore, you must use the star (<code>*</code>) for 
multiplication, <em>not</em> the letter x.</p>
</div>

<p>Instructions given on the console are called 
<em><strong>commands</strong></em>.  However, one can also assemble 
sequences of instructions, which are called 
<em><strong>programs</strong></em> and execute them together. Type

<pre>
1 PRINT "Hello World!"
</pre>

in the console and hit ENTER. Instead of just writing <code>Hello 
World!</code> on the canvas, the entire command gets &quot;moved&quot; up 
to the canvas. Something very important has happened: you have just written 
your first computer program. Congratulations!</p>

<div class="frame">
<p><strong>Trivia:</strong> ZX BASIC is a programming language in which 
the instructions for programs and the instructions for commands are 
exactly the same. Such languages are called <em>scripting 
languages</em>, because programs are like scripted commands.</p>
</div>

<p>To <em><strong>run</strong></em> the program, just type the 
<code>RUN</code> command. It does write <code>Hello World!</code> on the 
canvas, just like in the previous example, but the report is slightly 
different:</p>

<pre>
0 OK, 1:1
</pre>

<p>The difference is the statement identifier. It says <code>1:1</code> 
now instead of <code>0:1</code>. This is because the last statement 
executed was not directly from the console, but from <em>program 
line</em> 1. You can enter another program line, too:</p>

<pre>
2 PRINT "My name is ZX85."
</pre>

<p>When you ENTER this program line, it also moves up and you see this in 
the canvas area:</p>
<pre>
   1 PRINT "Hello World!"
   2<span style="background-color:currentColor"><span style="color:white">&gt;</span></span>PRINT "My name is ZX85."
</pre>

<p>That little <code><span style="background-color:currentColor"><span style="color:white">&gt;</span></span></code> sign after line number 
<code>2</code> is the so-called <em><strong>program 
cursor</strong></em>. You can move it up and down with the arrow keys 
and bring the pointed program line back down to the console by pressing 
the EDIT key for further EDITing. Now try giving your ZX85 a personal 
name by EDITing line 2. If you wish to delete a program line, just 
enter its number without any instructions. Thus, for example, entering 
<code>1</code> would remove the greeting from before the 
self-introduction.</p>

<p>In order to make it easier to insert new program lines in between 
existing ones, there is a convention to number program lines by the 
multiples of 10. The command <code>RENUM</code> re-numbers the program 
to follow this convention. After <code>RENUM</code>. the two-line 
program above becomes this:</p>

<pre>
  10 PRINT "Hello World!"
  20 PRINT "My name is ZX85."
</pre>

<p>Re-numbering does not change what the program does, at least for 
well-written programs, it just makes it easier to work on it.</p>

<p>Now you know enough to start programming your ZX85. In each of the 
following chapters, you find programs of increasingly complex computer 
games and explanations of how and why they work. You are encouraged to 
modify them, make them better and, eventually, write your own games</p>


<h2><a id="first"/>Guess the Number</h2>

<p>The following ten-line program is a simple number guessing game. The 
computer picks a random number between 1 and 1000 and you need to guess 
it. After each guess, the computer would tell you whether your guess was 
correct, too high or too low. Based on this information, you can close 
in on the number picked by the computer. Type in the following program 
and then enter the <code>RUN</code> command to play a game.</p>

<pre>
  10 LET number=1+INT (1000*RND)
  20 LET guesses=0
  30 REPEAT
  40  INPUT "Your guess?",guess
  50  IF guess&lt;number THEN PRINT guess;" is too low."
  60  IF guess&gt;number THEN PRINT guess;" is too high."
  70  LET guesses+=1
  80 UNTIL guess=number
  90 PRINT "Congratulations, you guessed ";number;"."
 100 PRINT "It took you ";guesses;" guesses."
</pre>

<p>When the game ends, the console shows the following report:
<pre>
0 OK, 100:1
</pre>
By now, you know what that means. You can always play another round by 
entering <code>RUN</code> again.</p>

<div class="frame">
<p><strong>Note:</strong> When the game asks you to guess a number, the 
separator stripe between the canvas and the console says 
<code>NUMERIC</code> instead of <code>BASIC</code> which means that it 
expects a number or a <em><strong>numeric expression</strong></em>; a 
formula that, when evaluated, results in a number. So, if you type 
<code>100+200</code>, it qualifies as a guess of <code>300</code>. Try 
it!</p>
</div>
<p></p>
<div class="frame">
<p><strong>Challenge:</strong> This behavior actually allows the player 
to &quot;cheat&quot; and always guess the number picked by the computer 
correctly upon first attempt. Wizards that are good at noticing and 
exploiting such opportunities are called <em><strong>hackers</strong></em>.
Can you think like a hacker and win the game in one guess every time?</p>
</div>

<p>Now, let's see what it actually does. In the first two lines 
(numbered <code>10</code> and <code>20</code>, respectively), the 
instruction keyword is <code>LET</code>. It 
<em><strong>assigns</strong></em> <em><strong>values</strong></em> to 
<em><strong>variable names</strong></em>. That is, it LETs the name mean 
a particular number, until further assignments. For example, in line 
<code>20</code>, the variable name <code>guesses</code> is made to stand 
for zero. You can try it separately. If you enter that line without the 
line number and then type <code>PRINT guesses</code> it will output 
<code>0</code>. If you enter <code>LET five=2+2</code> and then 
<code>PRINT five</code>, it will output <code>4</code>. This is 
perfectly <code>OK</code>, because <code>five</code> is just a name, and 
when a wizard uses a name, it means just what the wizard chooses it to 
mean &mdash; neither more nor less.</p>

<div class="frame">
<p><strong>Note:</strong> In ZX BASIC, anywhere where you can enter a 
number, you can also enter numeric expressions. There is only one 
exception from this rule: the line number before statements. Thus 
<code>2+2 PRINT</code> is not correct BASIC, but anywhere else where 
<code>4</code> is accepted, <code>2+2</code> or <code>2*(1+1)</code> is 
also accepted and means the same.</p>
</div>

<p>Line <code>10</code> has two keywords that are not even on the list 
of the previous chapter: <code>INT</code> and <code>RND</code>. This is 
because they are not instruction keywords. BASIC statements cannot begin 
with those. Let's explore them in more detail!</p>

<p><code>RND</code> is similar to variables, except that it does 
not need to be assigned and changes its value all by itself. It means a
random number that is at least zero and always less than 1. If you enter
<code>PRINT RND</code>, it will output a different fractional number
every time. Once in a while, it will output <code>0</code>, though the 
chances of that happening are pretty slim: one to 65536. It will never
output <code>1</code>, though it can get pretty close.</p>

<p>Thus, <code>1000*RND</code> is a number that is at least zero and 
always less than 1000. Try <code>PRINT 1000*RND</code> a few times. Most 
of these numbers have a fractional part after a decimal point. This is 
what <code>INT</code> removes. <code>INT</code> is a 
<em><strong>function</strong></em> that does something to the number 
that follows it. In particular, it turns it into an 
<em><strong>integer</strong></em> (which is just wizard-speak for whole 
numbers), removing the fractional part of numbers greater than zero.</p>
 
<p>However, <code>PRINT INT 1000*RND</code> does exactly the same as 
<code>PRINT 1000*RND</code> (try!). This is because the number that 
follows <code>INT</code> is <code>1000</code> so it takes the whole part 
of 1000, which is still 1000. Only then is it multiplied by 
<code>RND</code>. Similarly, <code>INT RND * 1000</code> is still not 
what we want (try it!), because the number following <code>INT</code> in 
this case is <code>RND</code>. Since <code>RND</code> has only a 
fractional part, <code>INT RND</code> is always zero. If you multiply 
that by 1000, it is still zero.</p>

<p>To exactly determine the order of operations, you need to use 
<code>(</code> and <code>)</code>, the so-called 
<em><strong>parentheses</strong></em>. What is between these is 
evaluated before what is outside of them. Hence, <code>INT 
(1000*RND)</code>. This results in a random whole number that is at 
least zero and less than 1000, that is at most 999. But since we want a 
random number between 1 and 1000, 1 needs to be added to it. Actually, 
<code>INT (RND*1000)+1</code> would work just the same. This is because 
the results of multiplication and addition do not change if we switch 
the order of the numbers to multiply or to add. Wizards call such 
operations <em><strong>commutative</strong></em>.</p>

<p>Line <code>30</code> contains a single keyword <code>REPEAT</code>. 
It means that what follows until the keyword <code>UNTIL</code> (see 
line <code>80</code>) must be repeated. It must be repeated 
UNTIL the condition following that keyword becomes true. 
In our case, until the player's <code>guess</code> and the <code>number</code> 
picked by the computer (in line <code>10</code>) become equal.</p>

<p>Now let's look to the four lines between <code>REPEAT</code> and 
<code>UNTIL</code>, which is what needs to be REPEATed.</p>

<p>Line <code>40</code> begins with the keyword <code>INPUT</code>. Its 
purpose is somewhat similar to that of <code>LET</code> in that it 
assigns values to variables, but, unlike <code>LET</code>, it reads the 
value from the console. The keyword <code>INPUT</code> is followed by a 
list consisting of things to write to the console and variable names 
which are to be assigned the values read from the console. These can be 
separated by comma (<code>,</code>, SYM+N), semicolon (<code>;</code>, 
SYM+O), or apostrophe (<code>'</code>, SYM+7). The difference is where 
the next item is going to appear on the console: in case of a comma, it 
is going to be neatly tabulated to either the middle of the line, or, if 
there is no space for that, to the beginning of the next line, in case 
of a semicolon, it is going to appear right after the end of the 
previous item, while in case of an apostrophe, it is going to appear at 
the beginning of the next line. Try changing the separator between 
<code>"Your guess?"</code> and <code>guess</code> in line 
<code>40</code> to see all this in action.</p>

<p>Lines <code>50</code> and <code>60</code> begin with an 
<code>IF</code> keyword followed by a condition, a <code>THEN</code> 
keyword and a <code>PRINT</code> statement. Such program lines execute 
the part after <code>THEN</code> only IF the condition following 
<code>IF</code> holds true.</p>

<p>Line <code>70</code> contains an unusual <code>LET</code> statement, 
a so-called <em><strong>update</strong></em>. It is, essentially, a 
shorthand for <code>LET guesses=guesses+1</code>. It requires less 
typing on the wizard's part and less interpreting on the computer's 
part.</p>

<p>Line <code>80</code> closes the <em><strong>loop</strong></em> 
started in line <code>30</code>. It is called a loop, because if you 
draw little arrows from each statement to possible next statements, your 
arrows are going to form a loop; a sequence of statements to be 
(possibly) repeated.</p>

<div class="frame">
<p><strong>Trivia:</strong> Loops that read the console and depending on 
what has been entered print something are called <em><strong>REPL</strong></em> by 
wizards, which stands for 
<strong>R</strong>ead -
<strong>E</strong>valuate -
<strong>P</strong>rint -
<strong>L</strong>oop. If you think about it, ZX BASIC itself is a REPL.</p>
</div>

<p>Lines <code>90</code> and <code>100</code> are just regular 
<code>PRINT</code> statements. Just like in <code>INPUT</code> the 
separators between things to be printed determine how they are going to be
positioned relative to one another on the canvas.</p>

<p>How many attempts do you need to guess the number without cheating? 
Let's switch sides with the ZX85 now and write a program that plays this 
same game as the guesser: the player thinks of a number and the computer 
tries to guess it.</p>

<pre>
  10 PRINT "Think of a whole number between 1 and 1000."''
  20 LET low=0: LET high=1024
  30 REPEAT
  40  LET guess=(low+high)/2
  50  PRINT "Is it ";guess;"?",
  60  INPUT "0: Too high."'"1: Too low."'"2: Correct."'answer
  70  IF answer=0
  80   LET high=guess
  90   PRINT "0: Too high."
 100  ELSE IF answer=1
 110   LET low=guess
 120   PRINT "1: Too high."
 130  ELSE IF answer=2
 140   PRINT "2: It is ";guess;"."
 150   STOP
 160  ELSE
 170   PRINT "I do not understand ";answer;"."
 180  END IF
 190 UNTIL high-low<2
 200 PRINT "This cannot be."'low;" is too low, but ";high;" is too high."
</pre>

<p>You may have noted that the initial high number is 1024, rather than 1001.
The reason for this is to make sure that the division in line <code>40</code>
always results in a whole number, since
1024 = 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2
that is two multiplied by itself ten times or, as wizards say:
&quot;two to the power of ten&quot;. It is written like 2<sup>10</sup>.
Thus, 1024 can be divided by 2 ten times, which is, not entirely by lucky 
coincidence, the maximum number of guesses the computer needs to guess a 
whole number between 1 and 1000.</p>

<p>The operation of multiplying a number by itself (or <em>taking 
powers</em> in wizard-speak) is denoted by the upwards-pointing arrow 
(<code>^</code>, SYM+H) in ZX BASIC. Try <code>PRINT 2^10</code>.
</p>

<p>Play this game a few times and note the sequences of answers you give 
to ZX85. It will always guess the number in no more than 10 questions and
for any given number, the sequence of questions and answers will be the
same. In fact, if you know that the number is somewhere between 1 and 1000,
the answers you give already uniquely identify the number. Now let us
modify the game a little bit. Change the following lines:</p>
<pre>
  50 PRINT "Is it at least ";guess;"?";TAB 22;
  60 INPUT "0: No, it is not."'"1: Yes, it is."'answer
  90 PRINT "0: No."
 120 PRINT "1: Yes."
 200 PRINT "The number is ";low;"."
</pre>
<p>Then delete lines <code>130</code> through <code>150</code>. You can
accomplish this by the command <code>DELETE 130 TO 150</code>. The new
keyword <code>TAB</code> in line <code>50</code> is similar to the 
comma, but it can tabulate to any position (22, in our case), not just
the middle of the line, which would be <code>TAB 16</code>.</p>

<p>Now you can <code>RUN</code> this &quot;new game&quot;. It is now more 
similar to <em>Twenty Questions</em> in that every question is answered 
by either &quot;yes&quot; or &quot;no&quot;. However, the computer will
always guess the number in exactly 10 questions. For example, 500 would be
guessed like this:
<pre>
Is it at least 512?   0: No.
Is it at least 256?   1: Yes.
Is it at least 384?   1: Yes.
Is it at least 448?   1: Yes.
Is it at least 480?   1: Yes.
Is it at least 496?   1: Yes.
Is it at least 504?   0: No.
Is it at least 500?   1: Yes.
Is it at least 502?   0: No.
Is it at least 501?   0: No.
The number is 500.
</pre>
If you change
the <code>1000</code> in line <code>10</code> to <code>1000000</code>
(one <em>million</em>) and also <code>high</code> in line <code>20</code>
from <code>1024</code> to <code>2^20</code> it will ask 20 questions before 
guessing the number. Any integer up to a million in just 20 yes/no
questions!</p>

<div class="frame">
<p><strong>Trivia:</strong> The strategy of picking the middle element 
in some ordering, comparing it to what you are looking for and based on 
whether or not it is greater, continuing either with the lower or the 
upper half of the ordering is called <em><strong>binary 
search</strong></em> and it is the wizard's way of quickly finding 
needles in haystacks. It is a simple, yet very powerful strategy (or 
<em><strong>algorithm</strong></em> in wizard-speak) from a broader 
class of <em><strong>divide and conquer</strong></em> algorithms. You 
are going to learn many of those and maybe invent some of your own. </p>

<p>Our word &quot;algorithm&quot; is honoring an outstanding medieval wizard,
<em>Muhammad al-Khwarizmi</em>, who invented or rigorously described several
algorithms that we regulary use to this day.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/f/fd/Khiva.jpg"
width="600" height="400" alt="Muhammad_ibn_Musa_al-Khwarizmi statue, Khiva">
<figcaption>The statue of Muhammad al-Khwarizmi in his native Khiva (in
today's Uzbekistan)</figcaption>
</div>
</div>

<p>The answers in <em>this</em> game <em>do</em> uniquely identify the 
integer and you do not even need to know how large it can be, as that 
can be learned from the <em>number</em> of answers. It is called 
<em><strong>binary representation</strong></em> and this is how 
computers represent numbers internally. In ZX Basic, you can use this 
representation using the <code>BIN</code> keyword. For example, you can 
write <code>BIN 0111110100</code> instead of <code>500</code>. Moreover, 
you can omit the leading zeroes, so <code>BIN 111110100</code> also 
means 500.</p>

<p>In general, <em>everything</em> is a sequence of zeroes 
and ones for the computer. Just like in the game above, it is common 
practice to represent &quot;yes&quot; by <code>1</code> and 
&quot;no&quot; by <code>0</code>. ZX85 actually does it all the time. 
For example, ask it whether two is less than one by typing <code>PRINT 
2&lt;1</code>. It will answer <code>0</code> by which it means 
&quot;No.&quot;. But to <code>PRINT 2&gt;1</code> or to 
<code>PRINT 2+2=4</code> it will answer <code>1</code> by which it means 
&quot;Yes.&quot;. Anywhere where you can write answers to yes/no questions,
you can also write numeric expressions, where those evaluating to zero
will be taken as a &quot;no&quot;, everything else as a &quot;yes&quot;.
For example, <code>IF 0 THEN PRINT "zero"</code> will not output anything,
but <code>IF 1 THEN PRINT "one"</code> will output <code>one</code> to
the canvas, and so will <code>IF 5 THEN PRINT "one"</code>.</p>

<p>Binary numbers are very important in wizardry, or as wizards call it, 
<em><strong>computer science</strong></em>. Those wishing to become 
wizards better learn to use them as second nature. For example, you 
should get into the habit of counting on your fingers in binary. Thus, 
instead of just 5, you will be able to count up to 31 on the fingers of 
one hand (be careful with showing number 4 to other people; muggles 
might misunderstand you). Each <em><strong>digit</strong></em> (which is 
just Latin for &quot;finger&quot;) in a binary number corresponds to a 
power of 2. Your thumb corresponds to 1 (which is 2<sup>0</sup>), your 
index finger corresponds to 2 (2<sup>1</sup>), your middle finger to 4 
(2<sup>2</sup>), your ring finger to 8 (2<sup>3</sup>) and your pinky to 
16 (2<sup>4</sup>). For example, if you want to show 7, you only extend 
your thumb, your index finger and your middle finger, becase 1 + 2 + 4 = 
7 (try <code>PRINT BIN 00111</code>). An extended thumb, index finger 
and pinky means 19 (which is 1 + 2 + 16, <code>BIN 10011</code>). In 
general, if you want to find out the binary representation of a number, 
you can either play the game above, or use another keyword, 
<code>STR$</code>. For example, <code>PRINT STR$ (30,2)</code> will be 
answered with <code>11110</code> (try it!), meaning all except your 
thumb extended. <code>STR$</code> is used to obtain various 
representations of numbers, with <code>2</code> meaning binary. The 
parentheses are needed, because otherwise <code>STR$</code> will only 
concern itself with <code>30</code>, the comma would mean tabulation to 
the middle of the line and <code>2</code> would mean 2. Try!</p>

<div class="frame">

<p><strong>Trivia:</strong> While all actual computers used today by 
humans are binary, it is not the only reasonable choice for digital 
computers. The reason humanity ended up using binary computers 
exclusively is that there are tremendous benefits in all computers being 
based on the same logic so that many things only need to be done once 
and used everywhere. The other reasonable choice for digital computers 
is <em><strong>ternary</strong></em>, which is based around the powers of 3 rather than 
two. The three kinds of digits there are -1, 0 and +1, meaning 
&quot;no&quot;, &quot;unknown&quot; and &quot;yes&quot;. Alien computers 
may very well be ternary. In fact, humanity has also explored ternary 
computing, an effort culminating in the serial production of a ternary 
computer named Setun' after a creek flowing through the campus of 
Lomonosov University in Moscow, Russia. But by the time the details were 
worked out to the point of practicality, binary computers were so 
widespread that it did not make much sense to continue. </p>

<p>However, this choice does not matter all that much. All digital 
computers can &quot;pretend to be&quot; (wizards say 
<em><strong>emulate</strong></em>) any other digital computer, so the 
(amazingly broad and to this day largely unexplored) set of problems 
that can be solved by digital computers does not depend on this choice. 
This universality (called <em><strong>Turing-completeness</strong></em> 
in his honor) was discovered and proven by an outstanding British wizard 
in the middle of the twentieth century, a pioneer of electronic 
computing, <em>Alan Turing</em>.</p>

<div class="figure">
<img 
src="https://upload.wikimedia.org/wikipedia/commons/a/a1/Alan_Turing_Aged_16.jpg" 
width="405" height="551" alt="Young Alan Turing">
<figcaption>Alan Turing, aged 16, before his great 
discoveries</figcaption>
</div>
</div>

<h2><a id="second"/>2048</h2>

<p>Now is the time to write the first game that is actually a lot of fun 
to play, to the point of being mildly addictive. The author readily 
admits to spending most of a twelve-hour trans-pacific flight playing 
this game on the onboard entertainment system. Playing this game will 
also help you memorize the powers of two. This game called 
<strong>2048</strong> was designed by an Italian wizard, Gabriele 
Cirulli in 2014.</p>

<p>The game is played on a 4×4 grid, starting out empty. Every turn, a 
new tile with a value 2 or 4 will appear in one of the empty spots. The 
player can slide the tiles with the arrow keys. Each tile slides until 
it hits another tile or the edge of the grid. When two tiles with the same 
number collide, they will merge into a tile carrying their total value.
The resulting tile will not merge in the same move. The game is won when
a tile with a value of 2048 appears. We can clear the board and restart
the game any time pressing the DELETE key.</p>

<p>We will add score- and time-keeping, colorful graphics and music to 
our game later, first we write the most important parts of the game so 
that it can be played. Let's begin with drawing the grid:</p>

<pre>
  10 LET b$="+----"*4+"+"+CHR$ 13
  20 PRINT (b$+("|    "*4+"|"+CHR$ 13)*4)*4+b$
</pre>

<p>There are several new things here. The variable name <code>b$</code> 
ends with <code>$</code> pronounced as <em><strong>string</strong></em>, 
making <code>b$</code> a <em><strong>string variable</strong></em>. The 
value it holds is a string, rather than a number. Strings are sequences 
of <em><strong>characters</strong></em>, which can be letters, digits, 
symbols, <em><strong>tokens</strong></em> or <em><strong>control 
characters</strong></em>. In fact, the quoted texts in previous examples 
are all strings. In the assignment of <code>b$</code> in line 
<code>10</code>, there is a <em>string expression</em>. The 
<code>+</code> between two strings results in a new string, consisting 
of the lefthand string immediately followed by the righthand string. For 
example <code>"Hello"+"World!"</code> would result in 
<code>HelloWorld!</code>. Try it! If there is a <code>*</code> between a 
string and a number (or a string expression and a numeric expression), 
it repeats the lefthand string the righthand number of times. For 
example, <code>"!"*3</code> results in <code>!!!</code>.</p>

<p>There is also a new keyword, <code>CHR$</code>. Keywords ending with 
<code>$</code> are <em><strong>string valued functions</strong></em> 
that turn their arguments into strings. In particular <code>CHR$</code> 
turns the number following it into one character with that particular 
<em>character code</em>, if that number is between 0 and 255. Character 
codes between 0 and 23 are <em><strong>control characters</strong></em>. 
Among them, <code>CHR$ 13</code> is known under a number of names: 
<em>Carriage Return, CR, Enter, New Line, Return</em>, but they all mean 
the same thing. It indicates the end of a line and a beginnig of a new 
line.</p>

<p>Thus, line <code>10</code> assings the following string to <code>b$</code>:
<pre>
+----+----+----+----+
</pre>
You can verify this by entering <code>PRINT b$</code>.</p>

<div class="frame">

<p><strong>Note:</strong> The program would work exactly the same, if we 
changed line <code>10</code> to this:
<pre>
  10 LET b$="+----+----+----+----+"+CHR$ 13
</pre>
However, that would take more time to type and would take up more memory of the 
computer. By typing a long and repetitive line like that the wizard does 
something that a computer can do better and faster. Why not let the computer
do all this tedious work?</p>

<p>Line <code>20</code> uses <code>b$</code> to draw the grid using similar 
techniques. By now, you know enough to understand every detail of it. Of 
course, instead of those two lines, one could naively write a sequence of 
<code>PRINT</code> statements:
<pre>
   1 PRINT "+----+----+----+----+"
   2 PRINT "|    |    |    |    |"
   3 PRINT "|    |    |    |    |"
   4 PRINT "|    |    |    |    |"
   5 PRINT "|    |    |    |    |"
   6 PRINT "+----+----+----+----+"
   7 PRINT "|    |    |    |    |"
   8 PRINT "|    |    |    |    |"
   9 PRINT "|    |    |    |    |"
  10 PRINT "|    |    |    |    |"
  11 PRINT "+----+----+----+----+"
  12 PRINT "|    |    |    |    |"
  13 PRINT "|    |    |    |    |"
  14 PRINT "|    |    |    |    |"
  15 PRINT "|    |    |    |    |"
  16 PRINT "+----+----+----+----+"
  17 PRINT "|    |    |    |    |"
  18 PRINT "|    |    |    |    |"
  19 PRINT "|    |    |    |    |"
  20 PRINT "|    |    |    |    |"
  21 PRINT "+----+----+----+----+" </pre>
But typing all that would be a huge waste of the wizard's time and the 
computer's memory. There are computer programs having such repetitive 
patterns in them and there are legitimate justifications for writing 
software like this, but these are typically written by another computer 
program. In a later chapter, we shall see how to write computer programs 
writing computer programs.</p>
</div>

<pre>
  30 DIM b(4,4)
</pre>

<p>The <code>DIM</code> keyword <em><strong>allocates</strong></em> an 
<em><strong>array</strong></em>. In this case, <code>b</code> is a 
<em><strong>numeric array</strong></em>, a collection of numeric 
variables. The numbers between parentheses following the array's name 
are called <em><strong>dimensions</strong></em>. Each element in the 
array is a variable that can be assigned a value. Initially, all of them 
are zero. One way to think about <code>DIM</code> is that it creates as 
many variables as the <em><strong>product</strong></em> (which is just 
wizard-speak for multiplication) of all its dimensions, in our case 16. 
Each variable's name is the name of the array, followed by a list of 
<em><strong>subscripts</strong></em> in parentheses, separated by 
commas. Each subscript is a number between 1 and the corresponding 
dimension. So, for example, <code>b(3,2)</code> is one of these 
variables, but <code>b(1,1,1)</code> or <code>b(5,2)</code> are not, if 
<code>b</code> was allocated according to line <code>30</code>. Try it! 
If you use wrong subscripts, ZX85 will report
<code>3 Subscript wrong</code>, an error.</p>

<p>The benefit of arrays compared to just naming variables, say, 
<code>b11</code> or <code>b32</code> is that subscripts can be numeric
expressions. That is the choice of which one to access or assign can
depend on other variables. A typical example when arrays are useful is when
the same operation needs to be performed with many variables. Without arrays,
one needs to write out the same operation for every variable. This is tedious
work not worth a wizard's time. Instead, you can (and should) use an array
and write a loop and make the computer perform the same operation on various
elements in the array. The wizard only needs to spell it out once. You will
see many examples of this in the game.</p>

<p>After drawing the board on the screen and allocating it in the 
computer's memory (as array <code>b</code> will hold the 
<em><strong>state</strong></em> of the board). we are ready to write the 
<em><strong>main loop</strong></em> of the game. Just like in the 
previous number guessing games, the main loop describes what happens in 
each turn of the game. Unlike the previous games, the main loop here is 
not a REPL, as the game only uses the canvas, not the console.<p>

<pre>
  40 REPEAT 
  50  PROC drop()
  60  REPEAT 
  70   LET action=0
  80   REPEAT 
  90    LET k=CODE INKEY$
 100   UNTIL k>=8 AND k<=12
 110   IF k=8 THEN PROC move(1,1,0,1)
 120   ELSE IF k=9 THEN PROC move(4,4,0,-1)
 130   ELSE IF k=10 THEN PROC move(4,1,-1,0)
 140   ELSE IF k=11 THEN PROC move(1,4,1,0)
 150  UNTIL action OR k=12
 160  PROC board()
 170 UNTIL k=12
 180 RUN
</pre>

<p>In line <code>50</code>, there is a new and very important keyword: 
<code>PROC</code>. It <em><strong>calls</strong></em> (or <em><strong>invokes</strong></em>) a 
<em><strong>procedure</strong></em>. A procedure is a program that has a name and can be
executed from another program (or itself). In this case, the name is
<code>drop</code> and the empty parentheses after the name indicate 
that it has no <em><strong>parameters</strong></em>. As its name might suggest, it drops a
tile with 2 or 4 on it onto a random empty cell of the grid. <em>How</em>
it does it is described later in the program.</p>

<p>The most important role of procedures is that it allows the wizard 
not to write the same sequence of statements in multiple places in the 
program. As you might have noticed, this kind of laziness is a cherished 
trait of wizards.</p>

<p>But <code>drop</code> is not called from anywhere else in our game. 
In line <code>50</code> we use a procedure for a different purpose. It 
has to do with making the code more understandable for other wizards, 
which very much includes ourselves some time later. A wise wizard 
acknowledges and works around the limitations of the human mind, 
including ones own. One such limitation is that we have a difficulty 
thinking on different levels of detail at the same time and even more 
difficulty following someone else's thoughts if they are doing that. It 
is important to keep in mind that even a mere two weeks from now you 
will be a different person. A very typical source of frustration with 
poor wizardry is trying to understand our own code written a long time 
ago. In the main loop of our game, we spell out the rules of the game 
and should not get into the minute details of placing a tile at a random 
empty location. There are no strict rules about what parts of code to 
place in separate procedures; it is an art, mastered with practice. 
However, if you find that it took you too much effort understading part 
of a program <em>because</em> it worked on a lower level of detail than 
its surrounding, do not hesitate to move it out into a procedure and 
give it a name that describes <em>what</em> it does, not getting into 
the details of <em>how</em> it is done. Such re-arranging of the code is 
called <em><strong>refactoring</strong></em> and even though it takes 
some effort, it saves a lot of time and nerves down the road. Avoiding 
it is the <em>wrong</em> kind of laziness.</p>

<p>The loop between lines <code>60</code> and <code>150</code> keeps 
running until something actually happens on the board. This is captured 
in the variable <code>action</code> assigned in line <code>70</code> 
meaning <em>no action</em> and perhaps changed in one of the 
<code>move</code>s in lines <code>110</code> through <code>140</code>. 
This is a loop within a loop, or as wizards call it, a 
<em><strong>nested loop</strong></em>.</p>

<p>In turn, it has another loop nested in it between lines 
<code>80</code> and <code>100</code>. In its 
<em><strong>body</strong></em>, it has a single <code>LET</code> 
statement with two new keywords. <code>CODE</code> is the reverse of 
<code>CHR$</code>. It takes a string and, if it is a single character, 
turns it into its character code, which is a number. The 
<code>CODE</code> of an <em><strong>empty string</strong></em> is zero. 
Try <code>PRINT CODE &quot;&quot;</code>. The keyword 
<code>INKEY$</code> means the key pressed, or an empty string, if no key 
is pressed. As the <code>$</code> at its end suggests, it is a string. 
Together, <code>CODE INKEY$</code> means the character code of the key 
that is pressed, or zero if there is none. You can try <code>REPEAT: 
PRINT AT 0,0;CODE INKEY$,:UNTIL 0</code> to see what code corresponds to 
which key on the keyboard. Character codes 8 through 11 correspond to 
the arrow keys, code 12 corresponds to DELETE. Hence, line 
<code>100</code> repeats the loop <code>UNTIL</code> one of them is 
pressed. If it is DELETE, the outer loops also quit.</p>

<p>Lines <code>110</code> through <code>140</code> are there to 
<code>move</code> the tiles in the direction of the arrow key pressed.</p>

<div class="frame">
<p><strong>Note:</strong> If you felt a bit of tedium while typing them in, 
it is a good sign, as this is somewhat unwizardly code, worthy of 
refactoring. It works correctly, but the parameters of <code>move</code> 
have to do with <em>how</em> to move the tiles in different directions, 
even though at this level we are supposed to be thinking about 
<em>what</em> needs to be done, not preoccupied with the minute details 
of <em>how</em>. So let's refactor it! These four lines express that the 
tiles need to be moved in the direction determined by the key pressed. 
We can replace it with a statement that expresses it more clearly:</p>

<pre>
DELETE 110 TO 140
110 IF k<>12 THEN PROC move(k-8)
</pre> 

<p>The <code>&lt;&gt;</code> sign means <em><strong>not 
equal</strong></em>. This change will require further changes in the 
<em><strong>definition</strong></em> of <code>PROC move</code> beginning 
with line <code>310</code>, which are discussed below it.</p>
</div>

<p>Line <code>160</code> redraws the board with all the tiles moved. The 
reason why redrawing is not part of <code>PROC move</code> is that we 
only want to redraw the board if some tiles have actually moved. Since the 
loop above this line keeps repeating until it happens, at this point we 
can be certain that at least one tile moved. The main loop continues until
the DELETE key is pressed, at which point the entire program is 
<code>RUN</code> again.</p>

<p>Now it is time to flesh out the procedures called from the main loop. The 
definitions of procedures begin with the <code>DEF PROC</code> keyword,
followed by the name of the procedure and its parameters. The definition
ends with the <code>END PROC</code> keyword.</p>

<pre>
 190 DEF PROC drop()
 200  LOCAL x,y,k
 210  FOR i=1 TO 4: FOR j=1 TO 4
 220   IF NOT b(i,j)
 230    LET k+=1
 240    IF RND<1/k THEN LET x=i: LET y=j
 250   END IF 
 260  NEXT : NEXT 
 270  LET k=1+(RND<.5)
 280  LET b(x,y)=k
 290  PROC tile(x,y,k)
 300 END PROC 
</pre>

<p>The <code>drop</code> procedure has no parameters. In line 
<code>200</code> we declare <em><strong>local variables</strong></em>. 
These variable names are used by the procedure but we do not want the 
procedure to interfere with the rest of the program, if it happens to 
use the same variable names for different purposes. For example, in the 
main loop we use <code>k</code> for the code of the key pressed, but 
inside <code>drop</code> we use it as a counter of empty cells in the 
grid and as the random value of the tile dropped. It is always a good 
idea to <em><strong>declare</strong></em> every variable that we intend 
to use inside a procedure as <code>LOCAL</code>, as it will reduce the 
possibility of unintended <em><strong>side effects</strong></em> of
our procedure. Also, since local variables are considered first when 
looking up a variable by name, this practice actually speeds up
the execution of our programs. Unless stated otherwise in the declaration,
local numeric variables are initialized to zero and local string variables
to the empty string.</p>

<p>Lines <code>210</code> through <code>260</code> describe two
nested <code>FOR</code> loops. These are loops that need to be executed
a given number of times (4, in our case). The <code>FOR</code> keyword 
is followed by the name of the <em><strong>loop variable</strong></em>,
that is going to take a different value during each execution (or
<em><strong>iteration</strong></em>) of the loop. These values are
determined by what follows the <code>=</code> sign: <code>1 TO 4</code>
means that it will be first assigned 1, then 2 and so on until the last
iteration in which it will be assigned 4. Thus, variables <code>i</code>
and <code>j</code> will be assigned all 16 possible combinations.
Try <code>FOR i=1 TO 4:FOR j=1 TO 4:PRINT "i=";i,"j=";j:NEXT:NEXT</code>
to get a better understanding of what goes on here.</p>

<div class="frame">
<p><strong>Note:</strong> The loop variable is always local to the loop.
The following command prints numbers from 1 to 5:</p>
<pre>
FOR i=1 TO 5: PRINT i: NEXT
</pre>
<p>Afterwards, however, <code>PRINT i</code> results in a
<pre>
2 Variable not found, 0:1
</pre>
report, because <code>i</code> is accessible only inside the loop.</p>

<p>There are no side effects even when nesting two loops with the same
loop variable name. Try this:
<pre>
FOR i=1 TO 10: FOR i=1 TO 10: PRINT "*";: NEXT: PRINT: NEXT
</pre>
<p>It will output a grid of 100 stars to the console:</p>
<pre>
**********
**********
**********
**********
**********
**********
**********
**********
**********
**********
</pre>
</div>

<p>Lines <code>220</code> and <code>250</code> mean that the entire body 
of these two nested loops is conditioned on <code>b(i,j)</code> being 
empty. An <code>IF</code> statement without a <code>THEN</code> keyword 
after the condition continues with the next statement, if the condition 
is <em>true</em>. If it is false, absent of an <code>ELSE</code> keyword,
it continues after the matching <code>END IF</code> keyword. In this case,
lines <code>230</code> and <code>240</code> are only executed if
<code>NOT b(i,j)</code> in line <code>220</code> is <em>true</em>, that is
if <code>b(i,j)</code> equals zero. This also shows the power of arrays,
as we can test 16 variables in a single loop with a handful of statements.</p>

<p>Line <code>230</code> counts empty cells in the grid in variable 
<code>k</code>. Line <code>240</code> replaces the values of 
<code>x</code> and <code>y</code> with the current values of 
<code>i</code> and <code>j</code> if with a probability 
<code>1/k</code>. In other words, at random, on average 1 out of 
<code>k</code> times, those values are replaced. At the first empty 
cell, when <code>k=1</code>, they are replaced with certainty, as 
<code>RND</code> is always less than one. When the loops have run their 
course, <code>x</code> and <code>y</code> contain the subscripts of one 
of the empty cells chosen randomly and uniformly from among all the empty
cells.</p>

<p>At this point, <code>k</code> contains the number of empty cells, but 
we do not want to do anything with that number. So, in line 
<code>270</code> we reuse <code>k</code> for a different purpose: it 
becomes either 1 or 2 with equal probability. It means which power of 
two the new tile will be: 2<sup>1</sup> (2) or 2<sup>2</sup> (4). In 
lines <code>280</code> and <code>290</code> this value is used to assign 
the corresponding <em><strong>element</strong></em> of array 
<code>b</code> and display the corresponding tile on the canvas. 
<code>PROC tile</code> is defined later, beginning with line 
<code>580</code>, as the details of drawing clearly do not belong to 
the procedure of random placement of a new tile.</p>

<pre>
 310 DEF PROC move(i,j,x,y)
 320  FOR n=1 TO 4
 330   PROC slide(i,j,x,y)
 340   LET i+=y: LET j-=x
 350  NEXT 
 360 END PROC 
</pre>

<p>The procedure <code>move</code> takes four parameters: the subscripts 
of one corner of the board and the numbers by which they are changed in 
each of the four iterations, as tile sliding and merging is calculated 
for all four rows or columns. The <em><strong>local</strong></em> 
variables to which parameter values are assigned are listed in the 
parentheses after the procedure name in the <code>DEF PROC</code> 
statement. <em>How</em> tile sliding is done is defined in procedure 
<code>slide</code>, which is called in line <code>330</code>. Since 
<em>parameter variables are local to the procedure</em>, there are no side 
effects from updating <code>i</code> and <code>j</code> in line 
<code>340</code>.</p>

<div class="frame">
<p><strong>Note:</strong> As noted in the discussion of the main loop,
it is better if the job of setting parameters <code>i</code>, <code>j</code>,
<code>x</code> and <code>y</code> depending on the direction of movement
would be the job of procedure <code>move</code> rather than the main loop.</p>
<p>The corresponding refactoring of procedure <code>move</code> would be
as follows:
</p>
<pre>
 310 DEF PROC move(k)
 315  LOCAL i=k?(1,4,4,1),j=k?(1,4,1,4),x=k?(0,0,-1,1),y=k?(1,-1,0,0)
</pre>
<p>Thus, <code>PROC move</code> takes a single parameter, the direction of
the movement, a number between <code>0</code> and <code>3</code>. In line
<code>315</code> the former parameters are declared as local variables 
and initialized with the appropriate values. The question mark <code>?</code>
operator is called <em><strong>selector</strong></em> and it picks 
the corresponding value from the list in the following parentheses. In order
to be able to use conditions before the question mark, the first value is 0.
For any value greater than the number of expressions in parentheses, the 
last one is used, though this can never happen in this program.
</p>
</div>

<pre>
 370 DEF PROC slide(i,j,x,y)
 380  LOCAL k=i,l=j
 390  FOR n=1 TO 3
 400   LET i+=x: LET j+=y
 410   IF b(i,j)
 420    WHILE b(k,l) AND b(k,l)<>b(i,j)
 430     LET k+=x: LET l+=y
 440    END WHILE 
 450    IF NOT b(k,l)
 460     LET b(k,l)=b(i,j)
 470     LET b(i,j)=0
 480     LET action=1
 490    ELSE IF b(k,l)=b(i,j) AND (i<>k OR j<>l)
 500     LET b(k,l)+=1
 510     LET k+=x: LET l+=y
 520     LET b(i,j)=0
 530     LET action=1
 540    END IF 
 550   END IF 
 560  NEXT 
 570 END PROC 
</pre>

<p>The parameters of procedure <code>slide</code> are subscripts 
<code>i</code> and <code>j</code> of the first cell of the row or column, 
the one <em>toward</em> which tiles are going to slide. Parameters
<code>x</code> and <code>y</code> are the values that need to be added to
<code>i</code> and <code>j</code>, respectively, to point to the next
cell of the grid (array <code>b</code>).</p>

<p>The procedure also has a new type of loop in it, the <code>WHILE</code> 
loop between lines <code>420</code> and <code>440</code>. The condition 
following <code>WHILE</code> is evaluated <em>before</em> each iteration 
of the loop. If it is <em>false</em> (that is zero), then execution 
continues <em>after</em> the <code>END WHILE</code> statement. 
Otherwise, the body of the loop is executed and the condition checked 
again. </p>

<div class="frame">
<p><strong>Note:</strong> Both <code>WHILE</code>/<code>END WHILE</code> 
and <code>REPEAT</code>/<code>UNTIL</code> loops depend on a condition. 
The main difference is that <code>REPEAT</code>/<code>UNTIL</code> loops 
execute <em>at least once</em>. <code>WHILE</code> loops are not 
executed at all, if their condition is <em>false</em> in the beginning. 
Another difference is that the condition after <code>WHILE</code> must 
be non-zero but the condition after <code>UNTIL</code> must be zero for
the loop's body to be executed one more time.</p>

<p>But there is also a subtler difference. The condition after 
<code>WHILE</code> is evaluated in the <em><strong>enclosing 
context</strong></em>, meaning that variables local to the loop are not 
accessible there. By contrast, the condition after <code>UNTIL</code> is 
evaluated in the <em><strong>local context</strong></em> of the loop 
itself, allowing for using variables local to the loop.</p>
</div>

<pre>
 580 DEF PROC board()
 590  FOR i=1 TO 4: FOR j=1 TO 4
 600   PROC tile(i,j,b(i,j))
 610  NEXT : NEXT 
 620 END PROC 
</pre>

<p>The <code>board</code> procedure simply iterates through all the cells of
the board and calls <code>PROC tile</code> to draw the tiles and empty
cells, as the case might be.</p>

<pre>
 630 DEF PROC tile(x,y,k)
 640  LOCAL k$=k?("",STR$ (2^k))
 650  LET k$=" "*(4-LEN k$)+k$
 660  PRINT AT x*5-2,y*5-4;k$
 670 END PROC 
</pre>

<p>This last procedure is used to draw one empty cell or a tile corresponding
to subscripts <code>x</code> and <code>y</code>. The keyword <code>LEN</code>
means the length of the string after it. Line <code>650</code> makes sure
that <code>k$</code> is always exactly 4 characters, with the number on the 
tile at the end of the string.</p>

<p>When we are going to change the graphics of the game to look prettier, 
have colors and so on, most changes go into this procedure. This first version
is very rudimentary, but it is (barely) enough to make the game playable.</p>



</body>
</html>

