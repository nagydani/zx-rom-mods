	INCLUDE	"../labels.asm"
	INCLUDE	"sysvars128.asm"

	ORG	$0000
; Cold reset
RST00:	DI
	LD	BC, $692B
RST00L:	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,RST00L	; No instruction fetch from 0008, for IF1 compatibility
	JP	RESET
	DEFS	$10 - $

; Print a character
RST10:	RST	$28
	DEFW	$0010
	RET
	DEFS	$18 - $

; Collect a character
RST18:	LD	HL,(CH_ADD)
	LD	A,(HL)
TEST_CHAR:
	CALL	SKIP_OVER
	RET	NC

; Collect next character
RST20:	CALL	CH_ADD_1
	JR	TEST_CHAR
	DEFS	$28 - $

; Call routine from ROM1
RST28:	EX	(SP),HL
	PUSH	AF
	LD	A,(HL)
	INC	HL
	INC	HL
	JP	CALL_ROM1
	DEFS	$30 - $

; Error restart in this ROM0
RST30:	PUSH	HL
	LD	HL,$0008
	EX	(SP),HL
	JP	SWAP
	DEFS	$38 - $

; IM1 routine
RST38:	PUSH	HL
	LD	HL,POPHLRET
	PUSH	HL
	LD	HL,SWAP
	PUSH	HL
	LD	HL,RST38
	PUSH	HL
	JP	SWAP
POPHLRET:
	POP	HL
	RET

CALL_ROM1:
	LD	(RETADDR),HL
	DEC	HL
	LD	H,(HL)
	LD	L,A
	POP	AF
	LD	(TARGET),HL
	LD	HL,YOUNGER
	EX	(SP),HL
	PUSH	HL
	LD	HL,(TARGET)
	EX	(SP),HL
	JP	SWAP

	DEFS	$66 - $
NMI:	PUSH	AF
	PUSH	HL
	LD	HL,(NMIADD)
	LD	A,H
	JR	Z,NONMI
	JP	(HL)
NONMI:	POP	HL
	POP	AF
	RETN

; This positions the compatibility switch to a guaranteed RET in ROM1
	DEFS	$0074 - $

SPECTRUM:
	LD	A,$30		; ROM 1, RAM 0, paging disabled
SPECTRUM_PAGE:
	LD	BC,$7FFD
	OUT	(C),A

NEW128:	DI
	XOR	A
	LD	(BANK_M),A
	LD	HL,(RAMTOP)
	JP	STARTN

INIT_5B00:	EQU	$

	ORG	$5B00
SWAP:	PUSH	AF
	PUSH	BC
	LD	BC,$7FFD
	LD	A,(BANK_M)
	XOR	$10
	DI
	LD	(BANK_M),A
	OUT	(C),A
	EI
	POP	BC
	POP	AF
	RET

YOUNGER:CALL	SWAP
	PUSH	HL
	LD	HL,(RETADDR)
	EX	(SP),HL
	RET

RAMNMI:	DI
	LD	BC,$7FFD
	LD	A,(BANK_M)
	OR	$10
	LD	(BANK_M),A
	OUT	(C),A
	JP	NMIVEC

POUT:	CALL	IOSWAP
PIN:	CALL	IOSWAP
SOUT:	CALL	IOSWAP
KOUT:	CALL	IOSWAP
KIN:	CALL	IOSWAP
XOUT:	CALL	IOSWAP
XIN:	CALL	IOSWAP
NXOUT:	CALL	IOSWAP
NXIN:	CALL	IOSWAP
DPEEK:	CALL	IOSWAP
IOSWAP:	LD	DE,IODISP
	PUSH	DE
	JP	SWAP

	DEFS	$5B57 - $
BANK_F:	DEFB	$06
TARGET:	DEFW	0
RETADDR:DEFW	0
BANK_M:	DEFB	0
RAMRST:	RST	$08
RAMERR:	DEFB	$0B
INIT_5B00_L:	EQU	$ - $5B00

	ORG	INIT_5B00 + INIT_5B00_L
IODISP:	EX	AF,AF'
	POP	DE
	LD	HL,IOJP-PIN
	ADD	HL,DE
	EX	AF,AF'
	JP	(HL)
IOJP:	JP	PR_OUT
	JP	PR_IN
	JP	S_OUT
	JP	K_OUT
	JP	K_IN
	JP	X_OUT
	JP	X_IN
	JP	NX_OUT
	JP	NX_IN
	JP	D_PEEK

; TODO: ugly hack, write proper, fast drivers
K_IN:	BIT	3,(IY+$02)
	CALL	NZ,ED_COPY
	LD	HL,(CHANS)
	LD	DE,(CURCHL)
	PUSH	DE
	LD	(CURCHL),HL
	RST	$28
	DEFW	L15E6		; INPUT-AD
K_INB:	JR	NC,KS_RET
	BIT	1,(IY+$07)
	JR	Z,KS_RET
	CP	$A5
	JR	C,KS_RET
	RES	1,(IY+$07)
	SUB	$A4
	SCF
	JR	KS_RET

K_OUT:	LD	HL,(CHANS)
	JR	KS_OUT
S_OUT:	LD	HL,(CHANS)
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
KS_OUT:
	LD	DE,(CURCHL)
	PUSH	DE
	LD	(CURCHL),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,KS_RET
	PUSH	HL
	LD	HL,SWAP
	PUSH	HL
	PUSH	DE
	JP	NC,SWAP
	LD	HL,PRINT_OUT
	AND	A
	SBC	HL,DE
	SCF
	JP	NZ,SWAP
	OR	A
	JR	Z,OUT_NIL
	CP	6
	CCF
	JP	C,SWAP
	EXX
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,TOKENS0
	LD	B,A
	CALL	TOKEN
	POP	HL
	POP	DE
	POP	BC
	EXX
OUT_NIL:INC	SP	; discard service routine address
	INC	SP
	INC	SP	; discard SWAP address
	INC	SP
	RET		; return to KS_RET
KS_RET:	POP	HL
	LD	(CURCHL),HL
PR_OUT:
PR_IN:
X_OUT:
X_IN:
NX_OUT:
NX_IN:
	JP	SWAP		; Empty plug

ED_COPY:RST	$28
	DEFW	L111D		; ED_COPY
	RET

R_LINK:	DEFB	$00, $03, $00, $07, $01, $00, $04, $FF

RESET:	LD	A,8		; check and clear all banks
	LD	HL,$FFFF
	LD	BC,$7FFD
	LD	DE,R_LINK+7
TESTL1:	DEC	A
	OUT	(C),A
	LD	(HL),A
	JR	NZ,TESTL1
	LD	A,8
TESTL2:	DEC	A
	LD	BC,$7FFD
	OUT	(C),A
	OUT	($FE),A
	CP	(HL)
	JR	Z,RAMOK
	HALT			; freeze with border showing the faulty RAM
RAMOK:	LD	SP,L3D00	; Two zero bytes for RET in ROM1
	INC	C
	IN	C,(C)
	BIT	0,C		; SPACE key pressed?
	JP	Z,SPECTRUM	; if so, enter compatibility mode
	EX	DE,HL
	LDD
	EX	DE,HL
	LD	BC,$4000
	INC	L
TESTL3:	DEC	L
	LD	(HL),C
	JR	NZ,TESTL3
	DEC	H
	DJNZ	TESTL3
	LD	HL,$FFFF
	OR	A
	JR	NZ,TESTL2

	LD	A,7
	OUT	($FE),A
	LD	SP,TSTACK
	EXX
	LD	HL,INIT_5B00
	LD	DE,$5B00
	LD	BC,INIT_5B00_L
	LDIR
	EXX
	LD	(P_RAMT),HL
	LD	DE,$3EAF
	LD	BC,$A8
	EX	DE,HL
	RST	$28
	DEFW	LDDRR
	EX	DE,HL
	INC	HL
	LD	(UDG),HL
	DEC	HL
	LD	BC,$0140
	LD	(RASP),BC
	LD	(RAMTOP),HL
STARTN:	LD	A,$10
	LD	(FLAGS),A	; indicate 128k mode
	LD	(HL),$3E
	DEC	HL
	LD	SP,HL
	CALL	SETTRAP
	LD	HL,$3C00
	LD	(CHARS),HL
	LD	HL,RAMNMI
	LD	(NMIADD),HL
	LD	IY,ERR_NR
	LD	A,$3F
	LD	I,A
	IM	1
	EI
	LD	HL,CHINFO
	LD	(CHANS),HL
	LD	DE,CHINFO0
	LD	BC,CHINFO0_E - CHINFO0
	EX	DE,HL
	LDIR
	EX	DE,HL
	DEC	HL
	LD	(DATADD),HL
	INC	HL
	LD	(PROG),HL
	LD	(VARS),HL
	LD	(HL),$80
	INC	HL
	LD	(E_LINE),HL
	LD	(HL),$0D
	INC	HL
	LD	(HL),$80
	INC	HL
	LD	(WORKSP),HL
	LD	(STKBOT),HL
	LD	(STKEND),HL
	LD	A,$38
	LD	(ATTR_P),A
	LD	(ATTR_T),A
	LD	(BORDCR),A
	LD	HL,$0523
	LD	(REPDEL),HL
	DEC	(IY-$3A)
	DEC	(IY-$36)
	LD	HL,INIT_STRM
	LD	DE,STRMS
	LD	BC,$0E
	LDIR
	LD	(IY+$31),$02
	RST	$28
	DEFW	L0D6B
	LD	DE,COPYRIGHT
	CALL	STDERR_MSG
	XOR	A
	LD	DE,L1539 - 1
	RST	$28
	DEFW	L0C0A
	SET	5,(IY+$02)
	LD	DE,L12A9
	PUSH	DE
	JP	SWAP

SETTRAP:LD	HL,TRAPST
	LD	DE,TSTACK - 1
	LD	BC,4
	LDDR
	EX	DE,HL
	INC	HL
	LD	(ERR_SP),HL
	RET
	DEFW	SWAP
	DEFW	TRAP128
TRAPST:	EQU	$ - 1

TRAP128:BIT	7,(IY+1)
	JR	Z,ERRCNT
	LD	HL,TRAPTAB
	LD	C,(IY+0)	; ERR_NR
	CALL	INDEXER
	JR	NC,ERRCNT
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	JP	(HL)
TRAPTAB:DEFB	0		; TODO: empty plug
ERRCNT:	LD	HL,(RAMTOP)
	DEC	HL
	DEC	HL
	DEC	HL
	LD	SP,HL
	CALL	SETTRAP
	JP	SWAP

CH_ADD_1:
	LD	HL,(CH_ADD)
	INC	HL
	LD	(CH_ADD),HL
	LD	A,(HL)
	RET

SKIP_OVER:
	CP	$21
	RET	NC
	CP	$0D
	RET	Z
	CP	1
	RET	C
	CP	6
	CCF
	RET	NC
	CP	$18
	CCF
	RET	C
	INC	HL
	CP	$16
	JR	C,SKIPS2
	INC	HL
SKIPS2:	SCF
	LD	(CH_ADD),HL
	RET

DISPAT:	BIT	4,(IY+1)
	JP	Z,GO48		; USR 0 mode
	LD	A,(BANK_M)
	AND	$C7
	LD	(BANK_M),A
	OUT	(C),A
	EI
	POP	BC
	POP	AF
	EX	(SP),HL
	PUSH	BC
	LD	BC,SKIPPER
	AND	A
	SBC	HL,BC
	ADD	HL,BC
	JR	Z,SKIP_CONT
	LD	BC,SCANNER
	AND	A
	SBC	HL,BC
	ADD	HL,BC
	JR	Z,SCAN_CONT
	LD	BC,OPENER
	AND	A
	SBC	HL,BC
	ADD	HL,BC
	POP	BC
	EX	(SP),HL
	JR	Z,OPEN_CONT
	JP	NEW128

SKIP_CONT:
	POP	BC
	EX	(SP),HL
	CP	1
	JP	C,SWAP
	CP	6
	CCF
	JP	SWAP
OPEN_CONT:
	LD	HL,OPENSTRM2
	JR	INDEX_CONT
SCAN_CONT:
	POP	BC
	EX	(SP),HL
	LD	HL,SCANFUNC2
INDEX_CONT:
	CALL	INDEXER
	JP	NC,SWAP
	POP	BC		; discard return address
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	JP	(HL)

INDEXER_1:
	INC	HL
INDEXER:LD	A,(HL)
	AND	A
	RET	Z
	CP	C
	INC	HL
	JR	NZ,INDEXER_1
	SCF
	RET

ERROR:	POP	HL
	LD	A,(HL)
ERRORA:	LD	(RAMERR),A
	RST	$28
	DEFW	RAMRST

STDERR_MSG:
	XOR	A
	PUSH	DE
	RST	$28
	DEFW	L1601
	POP	DE
	JR	MESSAGE
TOKEN:	LD	A,(DE)
	ADD	A,A
	INC	DE
	JR	NC,TOKEN
	DJNZ	TOKEN
MESSAGE:LD	A,(DE)
	AND	$7F
	RST	$10		; No need for recursion here
	LD	A,(DE)
	INC	DE
	ADD	A,A
	JR	NC,MESSAGE
	RET

OPENSTRM2:
	DEFB	0		; TODO: empty plug

CHINFO0:
K_CH:	DEFW	PRINT_OUT
	DEFW	L10A8
	DEFB	"K"
S_CH:	DEFW	PRINT_OUT
	DEFW	L15C4
	DEFB	"S"
R_CH:	DEFW	L0F81
	DEFW	L15C4
	DEFB	"R"
P_CH:	DEFW	POUT
	DEFW	PIN
	DEFB	"P"

KCHAN:	DEFW	KOUT
	DEFW	KIN
	DEFB	"K"
	DEFW	0
	DEFW	0		; TODO: proper close
	DEFW	KCHAN_E - KCHAN
KCHAN_E:
SCHAN:	DEFW	SOUT
	DEFW	L15C4
	DEFB	"S"
	DEFW	0
	DEFW	0		; TODO: proper close
	DEFW	SCHAN_E - SCHAN
SCHAN_E:
	DEFB	$80
CHINFO0_E:	EQU	$

INIT_STRM:
	DEFW	KCHAN - CHINFO0 + 1	; stream $FD offset to channel 'K'
        DEFW    SCHAN - CHINFO0 + 1	; stream $FE offset to channel 'S'
        DEFW    R_CH - CHINFO0 + 1	; stream $FF offset to channel 'R'

        DEFW    KCHAN - CHINFO0 + 1	; stream $00 offset to channel 'K'
        DEFW    KCHAN - CHINFO0 + 1	; stream $01 offset to channel 'K'
        DEFW    SCHAN - CHINFO0 + 1	; stream $02 offset to channel 'S'
        DEFW    P_CH - CHINFO0 + 1	; stream $03 offset to channel 'P'

COPYRIGHT:
	DEFB	$7F
	DEFM	" 2019 ePoint Systems Ltd"
TOKENS0:DEFB	$8D
	DEFM	"CELL"
	DEFB	$80+"$"
	DEFM	"MEM"
	DEFB	$80+"$"
	DEFM	"TIM"
	DEFB	$80+"E"
	DEFM	"STIC"
	DEFB	$80+"K"
	DEFM	"DPEEK"
	DEFB	$80+" "

MEM_T:	EQU	2
TIME_T:	EQU	3
STICK_T:EQU	4
DPEEK_T:EQU	5

SCANFUNC2:
	DEFB	MEM_T
	DEFB	S_MEM - $
	DEFB	TIME_T
	DEFB	S_TIME - $
	DEFB	DPEEK_T
	DEFB	S_DPEEK - $
	DEFB	STICK_T
	DEFB	S_STICK	-$
	DEFB	0

S_MEM:	RST	$20
	LD	HL,FLAGS
	RES	6,(HL)
	BIT	7,(HL)
	JR	Z,S_MEM_END
	LD	DE,1
	LD	BC,$FFFF
	RST	$28
	DEFW	L2AB1		; STK-ST-0
S_MEM_END:
	LD	BC,L2712
	PUSH	BC
	JP	SWAP

S_DPEEK:BIT	7,(IY+1)
	JR	Z,F_NUM
	LD	BC,DPEEK
	RST	$28
	DEFW	L2D2B		; STACK-BC
	LD	BC,$10ED	;USR
	PUSH	BC
	LD	BC,L270D	; S-PUSH-PO
	PUSH	BC
	LD	BC,$11C1	; TIGHT EXCHANGE
	JP	SWAP

F_NUM:	LD	BC,L270D	; S-PUSH-PO
	PUSH	BC
	LD	BC,$10EB	; like PEEK
	JP	SWAP

STICK_E:CALL	ERROR
	DEFB	$09		; A Invalid argument

S_STICK:RST	$28
	DEFW	L2522		; S-2-COORD
	JR	Z,S_TIME_END
	RST	$28
	DEFW	L2307		; STK-TO-BC
	DEC	D
	JR	NZ,STICK_E
	DEC	E
	JR	NZ,STICK_E
	RRA
	LD	A,B
	ADC	A,A
	CP	8
	JR	NC,STICK_E
	LD	HL,STICK_TAB
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	C,(HL)
	ADD	HL,BC
	JP	(HL)

S_TIME:	BIT	7,(IY+1)
	JR	Z,S_TIME_END
TIME_R:	LD	A,(FRAMES+2)
	LD	B,A
	LD	HL,(FRAMES)
	LD	A,(FRAMES+2)
	LD	DE,(FRAMES)
	CP	B
	JR	NZ,TIME_R
	SBC	HL,DE
	JR	NZ,TIME_R
	OR	A
	JR	Z,TIME_L
	LD	C,E
	LD	E,A
	LD	B,L
	LD	A,$98
TIME_N:	BIT	7,E
	JR	NZ,TIME_D
	SLA	C
	RL	D
	RL	E
	DEC	A
	JR	TIME_N
TIME_D:	RES	7,E
	JR	TIME_S
TIME_L:	LD	C,D
	LD	D,E
	LD	E,L
	LD	B,L
TIME_S:	RST	$28
	DEFW	L2AB6		; STK-STORE
S_TIME_END:
	LD	BC,L2630
	PUSH	BC
	LD	BC,TIME_T
	JP	SWAP

D_PEEK:	RST	$28
	DEFW	L1E99		; FP-TO-BC
	LD	L,C
	LD	H,B
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	JP	SWAP

STICK_TAB:
	DEFB	KEMPSTON_FIRE - $
	DEFB	KEMPSTON_STICK - $
	DEFB	SINCLAIR1_FIRE - $
	DEFB	SINCLAIR1_STICK - $
	DEFB	SINCLAIR2_FIRE - $
	DEFB	SINCLAIR2_STICK - $
	DEFB	CURSOR_FIRE - $
	DEFB	CURSOR_STICK - $

CURSOR_STICK:
	LD	A,$F7
	IN	A,($FE)
	CPL
	AND	$10
	RRCA
	RRCA
	LD	C,A
	LD	A,$EF
	IN	A,($FE)
	CPL
	LD	B,A
	AND	$18
	RRCA
	RRCA
	RRCA
	OR	C
	LD	C,A
	LD	A,B
	AND	$4
	ADD	A,A
	OR	C
	JR	STICK_END

SINCLAIR1_FIRE:
	LD	A,$EF
	IN	A,($FE)
	CPL
	AND	$01
	JR	STICK_END
CURSOR_FIRE:
SINCLAIR2_FIRE:
	LD	A,$F7
	IN	A,($FE)
	CPL
	JR	STICK_FIRE
KEMPSTON_FIRE:
	IN	A,($1F)
STICK_FIRE:
	AND	$10
	RRCA
	RRCA
	RRCA
	RRCA
STICK_END:
	RST	$28
	DEFW	L2D28		; STACK_A
	JR	S_TIME_END

SINCLAIR1_STICK:
	LD	A,$EF
	IN	A,($FE)
	LD	C,A
	LD	B,4
S2S_L:	RR	C
	ADC	A,A
	DJNZ	S2S_L
STICK_1:CPL
STICK_2:AND	$0F
	LD	B,A
	RRA
	SRL	A
	XOR	B
	AND	$03
	LD	C,A
	ADD	A,A
	ADD	A,A
	OR	C
	XOR	B
	JR	STICK_END

SINCLAIR2_STICK:
	LD	A,$F7
	IN	A,($FE)
	JR	STICK_1

KEMPSTON_STICK:
	IN	A,($1F)
	JR	STICK_2


	DEFS	$3CF8 - $
GO48:	LD	A,$10		; ROM1, RAM0
	OUT	(C),A
	JP	DISPAT
	NOP
	DEFS	$300
